### №21719 на КЕГЭ

#### Условие

В банке дистанционной проверяющей системы имеется более $100 000$ заданий. Все задачи пронумерованы начиная с единицы. Эти задания в течение учебного периода решают участники различных курсов. Каждому студенту при регистрации присваивается уникальный идентификатор — натуральное число, не превышающее $1 000 000$. Студент может сдать несколько различных правильных решений одной задачи, при этом в зачёт идёт только одно из них. Преподаватель сделал выгрузку результатов за некоторый период времени и выбрал студента, который решил наибольшее количество задач из банка через одну (одну решил, следующую нет и т.д.).

Определите *идентификационный номер студента*, который решил наибольшее количество задач через одну, и *количество решённых им задач*. Если несколько студентов решили одинаковое максимальное количество задач, то укажите студента с наименьшим идентификационным номером.

**Входные данные:**
В первой строке входного файла находится число **N** — количество зачтённых решений (натуральное число, не превышающее $60 000$) за некоторый период времени. Каждая из следующих **N** строк содержит два натуральных числа, не превышающих $1 000 000$: идентификатор студента и номер правильно решённой задачи.

**Выходные данные:**
Два целых неотрицательных числа: наименьший идентификационный номер студента и наибольшее количество успешно решённых задач через одну.

#### Решение
```python
with open("26_21719.txt") as file:
    n = int(file.readline())  # Первое число: кол-во зачтённых решений
    data = [list(map(int, line.split())) for line in file.readlines()]

# Группируем задачи по студентам
table = {}
for student, task in data:
    if student not in table:
        table[student] = set()  # Множество не содержит дубликаты
    table[student].add(task)

# Находим самую длинную последовательность задач через одну
def findLongestSeq(tasks):
    count = 0
    max_count = 0
    for i in range(1, len(tasks)):
        if tasks[i - 1] + 2 == tasks[i]:
            count += 1
        else:
            count += 1 
            if count > max_count:
                max_count = count
            count = 0
    return max_count

# Ищем студента с максимальной последовательностью
best_count = 0
best_student = None

for student in sorted(table.keys()):
    table[student] = list(table[student])  # Из set() -> list()
    count = findLongestSeq(table[student])
    
    if count > best_count:
        best_count = count
        best_student = student

print(best_student, best_count)
```


#### Простая идея решения

**Суть в одном предложении**: найти студента, который решил самую длинную цепочку задач, где номера отличаются на 2 (например: $5, 7, 9, 11, 13, \ldots$).

**Пример:** Студент решил задачи: `10, 12, 14, 16, 20`

Через одну — это: $10 \rightarrow 12 \rightarrow 14 \rightarrow 16$ (четыре задачи подряд с шагом $2$), потом $20$ выбивается из цепочки.
Ответ: $4$ задачи.

**Три шага алгоритма**

1. Группировка — собрать все задачи каждого студента отдельно
2. Поиск цепочек — для каждого студента найти самую длинную последовательность задач, где каждая следующая на $2$ больше предыдущей
3. Выбор лучшего — выбрать студента с самой длинной цепочкой (если ничья — берём с меньшим ID)

Вот и всё!