### №23765 на КЕГЭ

#### Условие
Отдел маркетинга сети магазинов составляет рейтинг продуктов по информации об их сроках хранения с момента изготовления и после вскрытия упаковки. Для каждого продукта известен срок его хранения с момента изготовления и срок годности к употреблению после вскрытия упаковки. Продукты пронумерованы начиная с единицы.

В рейтинговом списке маркетологи располагают продукты по следующему алгоритму:
- все **2N** чисел, обозначающих срок хранения и срок годности к употреблению для **N** продуктов, упорядочивают по возрастанию;
- если минимальное число в этом упорядоченном списке – срок хранения, то продукт в рейтинге занимает первое свободное место от
его начала;
- если минимальное число – срок годности к употреблению, то продукт занимает первое свободное место от конца рейтинга;
- если число обозначает срок хранения или срок годности к употреблению уже рассмотренного продукта, то его не принимают во внимание.

Этот алгоритм применяется последовательно для размещения всех **N** продуктов.

Определите *номер последнего продукта*, для которого будет определено его место в рейтинге, и *количество продуктов*, которые займут в рейтинге более низкие места.

**Входные данные:**
В первой строке входного файла находится натуральное число **N** (**N** ≤ $1000$) – количество продуктов. Следующие **N** строк содержат пары чисел, обозначающих соответственно срок хранения продукта с момента изготовления и срок годности к употреблению после вскрытия упаковки (все числа натуральные, различные).

**Выходные данные:**
Запишите в ответе два натуральных числа: сначала номер последнего продукта, для которого будет определено его место в рейтинге, затем – количество продуктов, которые займут в рейтинге более низкие места.

#### Решение

```python
with open("26_23765.txt") as file:
    n = int(file.readline())  # Первое число: кол-во продуктов
    data = [
        list(map(int, i.split(" "))) for i in file.readlines()
    ]

commonRating = []
for idx, (kh, vs) in enumerate(data, 1):
    commonRating.append(  [kh, idx, "срок хранения"]  )
    commonRating.append(  [vs, idx, "срок вскрытия"]  )

khranenie, vskrytie  = [], []

lastProduct = None
for number, key, type in sorted(commonRating):
    if key in khranenie or key in vskrytie:
        continue

    lastProduct = key
    if type == "срок хранения":
        khranenie.append(key)
    else:
        vskrytie.append(key)

count = 0
flag = False
for key in khranenie + vskrytie[::-1]:
    if flag is True:
        count += 1
    if key == lastProduct:
        flag = True

print(lastProduct, count)
```

#### Пояснение к решению

Ключевой момент: маркетологи строят рейтинг, обрабатывая **все 2N чисел** (сроки хранения и вскрытия) в отсортированном порядке. Для каждого минимального числа они:

- Если это **срок хранения** $\rightarrow$ продукт идёт в рейтинг **с начала** (позиция слева)
- Если это **срок вскрытия** $\rightarrow$ продукт идёт **с конца** (позиция справа)
- Если продукт уже был размещён $\rightarrow$ число игнорируется

Нужно найти номер **последнего обработанного продукта** и **сколько продуктов разместили после него** (в конце рейтинга).

**Шаг 1: Подготовка данных**

```python
commonRating = []
for idx, (kh, vs) in enumerate(data, 1):
    commonRating.append([kh, idx, "срок хранения"])
    commonRating.append([vs, idx, "срок вскрытия"])
```

Создаём список из **2N элементов**, где каждый содержит:

- Само число (срок)
- Номер продукта `idx`
- Тип (хранение или вскрытие)

**Шаг 2: Обработка в отсортированном порядке**

```python
khranenie, vskrytie = [], []
lastProduct = None

for number, key, type in sorted(commonRating):
    if key in khranenie or key in vskrytie:
        continue  # Продукт уже размещён — игнорируем
    
    lastProduct = key  # Запомним этот продукт
    if type == "срок хранения":
        khranenie.append(key)
    else:
        vskrytie.append(key)
```

Отсортируем весь `commonRating` по первому элементу (числовому значению сроков). Затем последовательно:

- Если продукт уже в одном из списков (`khranenie` или `vskrytie`) — пропускаем
- Иначе добавляем его в соответствующий список и запоминаем как `lastProduct`

**Шаг 3: Подсчёт продуктов в конце рейтинга**

```python
count = 0
flag = False
for key in khranenie + vskrytie[::-1]:
    if flag is True:
        count += 1
    if key == lastProduct:
        flag = True

print(lastProduct, count)
```

Конкатенируем оба списка: слева (хранение) + справа в **обратном порядке** (вскрытие). Это физический порядок в итоговом рейтинге.

Проходим по этому порядку и считаем продукты **после** `lastProduct`:

- `flag` становится `True` когда встретили `lastProduct`
- После этого каждый новый элемент — это продукт, занявший более низкое место