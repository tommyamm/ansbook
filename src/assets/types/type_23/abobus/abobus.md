### №24804 на КЕГЭ

#### Условие

Исполнитель преобразует число на экране. У исполнителя есть **три команды**, которые обозначены латинскими буквами:

| Команда | Действие |
|---------|----------|
| **A** | Умножить на 2 |
| **B** | Возвести в квадрат |
| **C** | Возвести в куб |

**Программа для исполнителя** – это последовательность команд.

**Траектория вычислений программы** – это последовательность результатов выполнения всех команд программы.

Сколько существует программ, для которых при **исходном числе 2** результатом является **число 131072**, при этом **траектория вычислений не содержит одновременно 4 и 16**?

#### Решение

```python
def fn(n, target, flag=0):
	if n == target:
		return 1
	if n > target:
		return 0 

	if n in [4, 16]:
		flag += 1

	if flag >= 2:
		return 0
	return fn(n * 2, target, flag) + \
		   fn(n ** 2, target, flag) + \
		   fn(n ** 3, target, flag)

print(fn(2, 131072))
```
```python
def fn(n, target, flag=0):
```
- `n` — текущее число
- `target` — целевое число (131072)
- `flag` — счётчик, сколько раз мы встретили "запрещённые" числа (4 или 16)

##### Базовые случаи

```python
if n == target:
    return 1
```
Если достигли цели — это **одна успешная программа**.

```python
if n > target:
    return 0
```
Если превысили цель — это **тупиковый путь** (программа не подходит).

##### Проверка ограничения

```python
if n in [4, 16]:
    flag += 1
if flag >= 2:
    return 0
```
Если текущее число — это 4 или 16, увеличиваем счётчик `flag`.

Если `flag ≥ 2`, значит мы уже встречали **оба** запрещённых числа → этот путь не подходит.

##### Рекурсивный перебор

```python
return fn(n * 2, target, flag) + \
	   fn(n ** 2, target, flag) + \
	   fn(n ** 3, target, flag)
```

Из текущего числа `n` пробуем все три команды:
1. `fn(n * 2, ...)` — применяем команду A
2. `fn(n ** 2, ...)` — применяем команду B
3. `fn(n ** 3, ...)` — применяем команду C

Суммируем количество успешных программ от каждого варианта.

##### Как работает алгоритм

Алгоритм использует **рекурсию с возвратом** (backtracking):

1. Начинаем с числа 2
2. На каждом шаге пробуем все три операции
3. Если встречаем 4 или 16 — запоминаем это в `flag`
4. Если встречаем оба числа (`flag ≥ 2`) — прерываем этот путь
5. Если достигаем 131072 — считаем это успешной программой
6. Суммируем все успешные пути

##### Пример траектории

**Допустимая траектория:**
```
2 → 4 (×2) → 16384 (возведение в куб: 4³ = 64, но это неправильно!)
```

Давайте правильно:
```
2 → 4 (команда A: ×2) → 64 (команда C: 4³) → 4096 (команда B: 64²) → ...
```
Эта траектория **недопустима**, так как содержит и 4, и 16 (если мы позже попадём в 16).

**Пример допустимой:**
```
2 → 8 (команда B: 2²×2 = 8) → 512 (команда C: 8³) → 131072 (возведение в квадрат неточно)
```

##### Важные замечания

⚠️ **Внимание:** В коде есть важная особенность — значение `flag` передаётся **по значению**, а не по ссылке. Это означает, что каждая ветвь рекурсии имеет свою копию счётчика, что корректно для данной задачи.