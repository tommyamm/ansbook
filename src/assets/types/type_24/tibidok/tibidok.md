### 21717 на КЕГЭ

#### Условие

Текстовый файл состоит из символов F, G, Q, R, S и W. Определите в этом файле минимальное количество идущих подряд символов, среди которых подстрока RSQ встречается ровно 130 раз, при этом искомая последовательность **не оканчивается** символом Q.
Для выполнения этого задания следует написать программу.

#### Решение

Задание 24 типа подразумевает использование метода **скользящее окно**. Именно этим методом будет решена задача.

```python
with open("24_21717.txt", "r") as file:
	data = file.readline()

notEnd = 'Q'
repeat = 130
subStr = 'RSQ'

lenSubStr = len(subStr)
lenData = len(data)

# Поиск позиций букв R в подстроках RSQ
indexes = []
for i in range(len(data) - lenSubStr + 1):
	if data[i : i + lenSubStr] == subStr:
		indexes.append(i)

minLen = float("inf")
for i in range(len(indexes) - repeat + 1):

	bgn = indexes[i]  # begin 
	end = indexes[i + repeat - 1]

	# trueEnd это "настоящий" индекс последнего элемента 
	# в подсписке, который не оканчивается на "Q". 
	# Например: RSQQQT выдаст позицию "T" (то есть 5)
	trueEnd = end + lenSubStr - 1
	while trueEnd < lenData and data[trueEnd] == notEnd:
		trueEnd += 1

	# Если дошли до конца data, значит так и не нашли
	# настоящий конечный индекс, значит скипаем такое
	if trueEnd == lenData:
		continue

	# Формирум кандидатов на искомый подсписок min длинны
	temp = data[bgn : trueEnd + 1]
	lenTemp = len(temp) 

	if lenTemp < minLen:  # находим минимальную длинну
		minLen = lenTemp

print(minLen)
```

#### Немного теории

Метод **скользящего окна** (англ. *sliding window*) — это эффективная техника, используемая для решения задач, связанных с поиском подпоследовательностей, подстрок или подмассивов в более крупной последовательности (строке, массиве, списке). Он особенно полезен, когда необходимо найти сегмент данных, удовлетворяющий определённым условиям, например, имеющий минимальную или максимальную длину, или содержащий определённое количество элементов.

#### Что такое скользящее окно?

Представьте, что у вас есть длинная строка символов или последовательность чисел. Метод скользящего окна работает по аналогии с физическим окном, которое вы можете перемещать вдоль этой последовательности. Это "окно" представляет собой непрерывный подсегмент данных, который мы анализируем.

Далее мы подробно разберём, как этот метод реализован в предоставленном коде.

```python
# Поиск позиций букв R в подстроках RSQ
indexes = []
for i in range(len(data) - lenSubStr + 1):
	if data[i : i + lenSubStr] == subStr:
		indexes.append(i)
```

**1. Поиск всех вхождений `RSQ`:**

Этот блок кода находит все начальные позиции (индексы) подстроки `RSQ` в исходной строке `data`. Цикл проходит по всем возможным начальным позициям `i` для подстроки `subStr`. Цикл проверяет, является ли срез `data[i : i + lenSubStr]` равным `subStr`. Если найдено совпадение, начальный индекс `i` этого вхождения добавляется в список `indexes`. Этот список будет содержать индексы всех `R` в найденных `RSQ`.

**Пример:**

Пусть  `data = "RSQWRSQRSQ"`, тогда `indexes` будет `[0, 4, 7]`.

**2. Применение метода скользящего окна и поиск минимальной длины:**

```python
minLen = float("inf")
```
Инициализируем переменную `minLen` бесконечно большим значением. Это нужно для того, чтобы любое первое найденное значение длины было меньше и стало начальным `minLen`.

```python
for i in range(len(indexes) - repeat + 1)
```
Это основной цикл, реализующий идею скользящего окна. Он перебирает все возможные **начальные** вхождения `RSQ` для формирования окна, содержащего `repeat`(130) таких подстрок. `indexes[i]`— это начальный индекс `R` первого `RSQ` в текущем окне. `indexes[i + repeat - 1]`— это начальный индекс `R` последнего (130-го) `RSQ` в текущем окне.

```python
bgn = indexes[i]
```
Определяет начальный индекс текущего "окна" (первый `R` в первом `RSQ`).

```python
end = indexes[i + repeat - 1]
```
Определяет начальный индекс последнего `RSQ` в текущем окне.

```python
trueEnd = end + lenSubStr - 1
```
Изначально `trueEnd` указывает на последний символ `Q` последнего `RSQ` в окне. Это **временный** конец подстроки.

```python
while trueEnd < lenData and data[trueEnd] == notEnd:
``` 
Это критически важная часть, которая обрабатывает условие **"не оканчивается символом Q"**. Цикл `while` расширяет `trueEnd` до тех пор, пока текущий символ `data[trueEnd]` равен `notEnd` ('Q') или пока не достигнут конец строки `data`. Таким образом, `trueEnd` будет указывать на первый символ, который **не является 'Q'**, после последнего `RSQ`, или на конец строки, если все последующие символы — 'Q'.

```python
if trueEnd == lenData:
```
Если `trueEnd` достиг конца строки `data`, это означает, что после последнего `RSQ` все оставшиеся символы были `Q`. В этом случае невозможно найти подстроку, которая не оканчивается на `Q`, поэтому текущий вариант пропускается (`continue`).

```python
temp = data[bgn : trueEnd + 1]
```
Формируется текущая подстрока-кандидат. Она начинается с `bgn` (первый `R` первого `RSQ`) и заканчивается `trueEnd` (первый символ, не `Q`, после последнего `RSQ`). `+1` нужен, потому что срез в Python не включает символ по конечному индексу.

**Ключевые моменты:**

`1)` Предварительный сбор всех индексов `RSQ` позволяет быстро определять начало и конец окна, содержащего нужное количество вхождений.

`2)` Расширение `trueEnd` с помощью `while` цикла — это адаптация метода скользящего окна для учёта дополнительного условия на конечный символ, что делает окно переменным по длине, несмотря на фиксированное количество `RSQ` внутри.