
### №23571 на КЕГЭ

Учёный решил провести кластеризацию некоторого множества звёзд по их расположению на карте звёздного неба. Кластер звёзд – это набор не менее чем из $30$ соседних звёзд (точек) на графике. Каждая звезда обязательно принадлежит только одному из кластеров. Центр кластера, или центроид, – это одна из звёзд на графике, сумма расстояний от которой до всех остальных точек кластера минимальна.

Расстояние между двумя точками на плоскости $A(x_1, y_1)$ и $B(x_2, y_2)$ вычисляется по формуле: $$d(A, B) = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$$

Аномалиями назовём точки, находящиеся на расстоянии более одной условной единицы от точек кластеров. При расчётах аномалии учитывать не нужно.

В файле $А$ хранятся данные о звёздах двух кластеров. В каждой строке записана информация о расположении на карте одной звезды: сначала координата $х$, затем координата $у$. Значения даны в условных единицах. Известно, что количество звёзд не превышает $1000$.

В файле $B$ хранятся данные о звёздах трёх кластеров. Известно, что количество звёзд не превышает **1000**. Структура хранения информации о звездах в файле $B$ аналогична файлу $A$.
Известно, что в файле  $B$ передаче данных. Эти три имеются координаты ровно трёх «лишних» точек, являющихся аномалиями, возникшими в результате помех при точки не относятся ни к одному из кластеров, их учитывать не нужно.

Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа: ${P_x}$ — среднее арифметическое абсцисс центров кластеров, и ${P_y}$ — среднее арифметическое ординат центров кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть произведения ${P_x \times 100000}$, затем целую часть произведения ${P_y \times 100000}$ для файла $А$, во второй строке — аналогичные данные для файла $B$.

#### Напишем вспомогательные функции

Функция для построения графика. Нужна для представления данных в файлах. На ЕГЭ мы не можем использовать бибилиотеку `matplotlib`, однако можем в Excel построить такой же график, чтобы понять, как кластеризовать.

```python
def plot(data, color='blue'):
  x_values = [point[x] for point in data]
  y_values = [point[y] for point in data]  

  plt.scatter(x_values, y_values, color=color)
```

Построит точечный график
![График для файла Б](/ansbook/src/assets/types/type_27/babacapa/image.png)

Удобная функция для рассчета коэффициентов прямой по двум точкам
```python
def get_coef(p1, p2):
    k = ((p2[y] - p1[y]) / p2[x]) / (1 - p1[x] / p2[x])
    b = (p1[y] - (p1[x] * p2[y]) / p2[x]) / (1 - p1[x] / p2[x])

    k = round(k, 3)
    b = round(b, 3)

    return f'Y = {k} * X + ({b})'
```

Основная функция кластеризации
```python
def clusterization(data):
  clasters = [[], [], []]
  for point in data:
    if point[y] < -1.42 * point[x] + 10.856:
      clasters[0].append(point)
    elif point[y] < -1.223 * point[x] + (15.009) and point[x] < 9:
      clasters[1].append(point)
    else:
      clasters[2].append(point)
  return clasters
```

Функция вычисления расстояния между двумя точками
```python
def dist(point_a, point_b):
    return (
        (point_b[x] - point_a[x]) ** 2 + 
        (point_b[y] - point_a[y]) ** 2
        ) ** 0.5
```

Функция вычисления центра кластера
```python
def get_center(claster):
    center = None
    min_sum = float('inf')
    for point in claster:
        sum_ = sum([dist(point, other) for other in claster])
        if sum_ < min_sum:
            min_sum = sum_
            center = point
    return center
```

Функция удаления выбросов (аномалий) из выборки
```python
def clear_data(data):
  clear  = []
  for point in data:
    if point[y] > point[x] + 5:
      continue
    if point[y] > -point[x] + 20:
      continue
    if point[y] < point[x] - 12:
      continue
    clear.append(point)
  return clear

```

Основная логика решения задачи
```python
import matplotlib.pyplot as plt

with open("27B_18677.txt", "r") as file:
  data =  [list(map(float, i.replace(",", ".").split('\t'))) for i in file.readlines()]

x, y = 0, 1

# 1. Очистим от выбросов
data = clear_data(data)

# 2. Кластеризуем (3 кластера в "В" файле)
claster_1, claster_2, claster_3 = clusterization(data)

# 3. Добавим на холст получившиеся кластеры (разным цветом)
plot(claster_1, 'red')
plot(claster_2, 'black')
plot(claster_3, 'blue')

# 4. Найдем центры каждого кластера
cent_1 = get_center(claster_1)
cent_2 = get_center(claster_2)
cent_3 = get_center(claster_3)

# 5. Найдем и выведем результат в тебуемом формате 
p_x = abs(int(((cent_1[x] + cent_2[x] + cent_3[x]) / 3) * 100_000))
p_y = abs(int(((cent_1[y] + cent_2[y] + cent_3[y]) / 3) * 100_000))
print(p_x, p_y)

# 6. Отобразим холст, включив сетку
plt.grid(True)
plt.show()
```

#### Уточнения
1) Точки для кластеризации:
```python
print(get_coef([3.709, 5.588], [7.780, -0.194]))
print(get_coef([5.174, 8.680], [9.000, 4.0000]))
```

Уравнения имеют вид:
```
Y = -1.42 * X + 10.86
Y = -1.22 * X + 15.01
```

2) Точки для очистки от выбросов:
```python
print(get_coef([3 , 8 ], [4 , 9 ]))
print(get_coef([10, 10], [11, 9 ]))
print(get_coef([9 , -3], [10, -2]))
```

Уравнения имеют вид:
```
Y = 1.0  * X + 5
Y = -1.0 * X + 20
Y = 1.0  * X - 12
```

#### Ответ для файла B
```
669946 370701
```